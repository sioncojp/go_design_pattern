# Decorator

behaviorを含む特別なラッパーオブジェクト内にこれらのオブジェクトを配置することにより、オブジェクトに新しいビヘイビアをアタッチできる構造設計パターン

オブジェクトを使用するコードを壊すことなく、実行時にオブジェクトに追加の動作を割り当てることができる必要がある場合

### メリット
- 新しいサブクラスを作成せずに、オブジェクトの動作を拡張できます。
- 実行時にオブジェクトに責任を追加または削除できます。
- オブジェクトを複数のデコレータにラップすることで、いくつかの動作を組み合わせることができます。
- 単一責任の原則。動作の多くの可能なバリアントを実装するモノリシッククラスをいくつかの小さなクラスに分割できます。

### デメリット
- ラッパースタックから特定のラッパーを削除するのは困難です。
- その動作がデコレータスタック内の順序に依存しないような方法でデコレータを実装することは困難です。
- レイヤーの初期構成コードはかなり見苦しいかもしれません。

### 他パターンとの関係性
- Adapter...既存のオブジェクトのインターフェースを変更
- Decorator...インターフェースを変更せずにオブジェクトを拡張

- Adapter...ラップされたオブジェクトに異なるインターフェイスを提供
- Proxy...同じインターフェイスを提供
- Decorator...拡張されたインターフェイスを提供

- Chain ofResponsibilityとDecoratorのクラス構造は非常に似ている
- CompositeとDecoratorはどちらも再帰的な構成に依存して自由形式の数のオブジェクトを編成するため、同様の構造図を持っている
- CompositeとDecoratorを多用する設計では、多くの場合、Prototypeを使用することでメリットが得られます
- Decoratorはオブジェクトのスキン変更。Strategyは内臓を変更


### 例題
- ピザ
- ベースとなるベジマニアピザがある
- そこにトッピングができる
    - トマト
    - チーズ
- トッピングをすると値段も変わる