# Flyweight

各オブジェクトのすべてのデータを保持する代わりに、複数のオブジェクト間で状態の共通部分を共有することにより、より多くのオブジェクトを使用可能なRAMの量に収めることができる構造設計パターン

プログラムが使用可能なRAMにかろうじて収まる膨大な数のオブジェクトをサポートする必要がある場合

### メリット
- プログラムに同様のオブジェクトがたくさんあると仮定すると、RAMを大量に節約できます。

### デメリット
- 誰かがflyweightメソッドを呼び出すたびにコンテキストデータの一部を再計算する必要がある場合、CPUサイクルでRAMを交換している可能性があります。
- コードははるかに複雑になります。
  - 新しいチームメンバーは、エンティティの状態がなぜこのように分離されたのか、常に疑問に思うでしょう。

### 他パターンとの関係性
- Composite Treeの共有リーフノードをFlyweightsとして実装して、RAMを節約できます。
- Flyweight...多くの小さなオブジェクトを作成
- Facade...サブシステム全体を表す単一のオブジェクトを作成
- オブジェクトのすべての共有状態を1つのFlyweightオブジェクトに減らすことができた場合、FlyweightはSingletonに似てる

### 例題
- CounterStrikeのゲーム
- TとCTがあって異なるドレスがある
- プレイヤー構造体にドレスが埋め込まれてる
- 5 vs 5 = 10のプレイヤーがいる
- 10個のプレーヤーオブジェクトのそれぞれが異なるドレスオブジェクトを作成し、それらを埋め込みます 
    - = 合計10個のドレスオブジェクトが作成
- 2つのドレスオブジェクトを作成
    - TとCT
- Flyweightパターンは、共通のパーツを取り出して、Flyweightオブジェクトを作成