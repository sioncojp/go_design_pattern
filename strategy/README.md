# Strategy
アルゴリズムのファミリーを定義し、それぞれを個別のクラスに配置し、オブジェクトを交換可能にする動作設計パターン

オブジェクト内でアルゴリズムのさまざまなバリアントを使用し、実行時に1つのアルゴリズムから別のアルゴリズムに切り替えることができるようにする場合

### メリット
- 実行時にオブジェクト内で使用されるアルゴリズムを交換できます。
- アルゴリズムの実装の詳細を、それを使用するコードから分離できます。
- 継承を構成に置き換えることができます。
- オープン/クローズド原則。コンテキストを変更せずに、新しい戦略を導入できます。

### デメリット
- アルゴリズムが2つしかなく、それらがほとんど変更されない場合は複雑化しすぎる
- クライアントは、適切な戦略を選択できるようにするために、戦略間の違いを認識している必要があります。
- 最新のプログラミング言語の多くは、無名関数のセット内にさまざまなバージョンのアルゴリズムを実装できる関数型をサポートしている。
  - これらの関数を、ストラテジーオブジェクトを使用した場合とまったく同じように使用できますが、追加のクラスやインターフェイスでコードを肥大化させることはありません。

### 他パターンとの関係性
- Bridge、State、Strategy（およびある程度Adapter）の構造は非常に似ています
- CommandとStrategyは両方を使用してオブジェクトを何らかのアクションでパラメーター化できるため、似ているように見える場合があるが違う
  - Command...任意の操作をオブジェクトに変換
  - Strategy...同じことを行うさまざまな方法を説明し、単一のコンテキストクラス内でこれらのアルゴリズムを交換
- Decoratorはオブジェクトのスキン変更。Strategyは内臓を変更
- TemplateMethodは継承に基づく。Strategyは構成に基づく
- StateはStrategyの延長

### 例題
- インメモリキャッシュを構築
- メモリ内にあるため、サイズに制限
- 最大サイズに達するたびに、スペースを解放 = 一部のエントリを削除する必要
    - 最も最近使用されていない（LRU）：最も最近使用されていないエントリを削除します。 
    - 先入れ先出し（FIFO）：最初に作成されたエントリを削除します。 
    - 使用頻度が最も低い（LFU）：使用頻度が最も低いエントリを削除します。
    
- 課題は、実行時にアルゴリズムを変更できるように、キャッシュクラスをこれらのアルゴリズムから分離する方法
- また、新しいアルゴリズムが追加されているときに、キャッシュクラスが変更されないようにする必要

